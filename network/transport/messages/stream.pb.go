// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: examples/raiden/messages/stream.proto

package messages

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import bytes "bytes"

import strings "strings"
import reflect "reflect"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// basic types definition
type ChainID struct {
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *ChainID) Reset()      { *m = ChainID{} }
func (*ChainID) ProtoMessage() {}
func (*ChainID) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{0}
}
func (m *ChainID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChainID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainID.Merge(dst, src)
}
func (m *ChainID) XXX_Size() int {
	return m.Size()
}
func (m *ChainID) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainID.DiscardUnknown(m)
}

var xxx_messageInfo_ChainID proto.InternalMessageInfo

func (m *ChainID) GetChainId() uint64 {
	if m != nil {
		return m.ChainId
	}
	return 0
}

type TokenAmount struct {
	TokenAmount uint64 `protobuf:"varint,1,opt,name=token_amount,json=tokenAmount,proto3" json:"token_amount,omitempty"`
}

func (m *TokenAmount) Reset()      { *m = TokenAmount{} }
func (*TokenAmount) ProtoMessage() {}
func (*TokenAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{1}
}
func (m *TokenAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TokenAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenAmount.Merge(dst, src)
}
func (m *TokenAmount) XXX_Size() int {
	return m.Size()
}
func (m *TokenAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenAmount.DiscardUnknown(m)
}

var xxx_messageInfo_TokenAmount proto.InternalMessageInfo

func (m *TokenAmount) GetTokenAmount() uint64 {
	if m != nil {
		return m.TokenAmount
	}
	return 0
}

type Locksroot struct {
	Locksroot []byte `protobuf:"bytes,1,opt,name=locksroot,proto3" json:"locksroot,omitempty"`
}

func (m *Locksroot) Reset()      { *m = Locksroot{} }
func (*Locksroot) ProtoMessage() {}
func (*Locksroot) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{2}
}
func (m *Locksroot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Locksroot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Locksroot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Locksroot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Locksroot.Merge(dst, src)
}
func (m *Locksroot) XXX_Size() int {
	return m.Size()
}
func (m *Locksroot) XXX_DiscardUnknown() {
	xxx_messageInfo_Locksroot.DiscardUnknown(m)
}

var xxx_messageInfo_Locksroot proto.InternalMessageInfo

func (m *Locksroot) GetLocksroot() []byte {
	if m != nil {
		return m.Locksroot
	}
	return nil
}

type ChannelID struct {
	ChannelId uint64 `protobuf:"varint,1,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (m *ChannelID) Reset()      { *m = ChannelID{} }
func (*ChannelID) ProtoMessage() {}
func (*ChannelID) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{3}
}
func (m *ChannelID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *ChannelID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelID.Merge(dst, src)
}
func (m *ChannelID) XXX_Size() int {
	return m.Size()
}
func (m *ChannelID) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelID.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelID proto.InternalMessageInfo

func (m *ChannelID) GetChannelId() uint64 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

type TokenNetworkAddress struct {
	TokenNetworkAddress []byte `protobuf:"bytes,1,opt,name=token_network_address,json=tokenNetworkAddress,proto3" json:"token_network_address,omitempty"`
}

func (m *TokenNetworkAddress) Reset()      { *m = TokenNetworkAddress{} }
func (*TokenNetworkAddress) ProtoMessage() {}
func (*TokenNetworkAddress) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{4}
}
func (m *TokenNetworkAddress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenNetworkAddress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenNetworkAddress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *TokenNetworkAddress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenNetworkAddress.Merge(dst, src)
}
func (m *TokenNetworkAddress) XXX_Size() int {
	return m.Size()
}
func (m *TokenNetworkAddress) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenNetworkAddress.DiscardUnknown(m)
}

var xxx_messageInfo_TokenNetworkAddress proto.InternalMessageInfo

func (m *TokenNetworkAddress) GetTokenNetworkAddress() []byte {
	if m != nil {
		return m.TokenNetworkAddress
	}
	return nil
}

type MessageID struct {
	MessageId uint64 `protobuf:"varint,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
}

func (m *MessageID) Reset()      { *m = MessageID{} }
func (*MessageID) ProtoMessage() {}
func (*MessageID) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{5}
}
func (m *MessageID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *MessageID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageID.Merge(dst, src)
}
func (m *MessageID) XXX_Size() int {
	return m.Size()
}
func (m *MessageID) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageID.DiscardUnknown(m)
}

var xxx_messageInfo_MessageID proto.InternalMessageInfo

func (m *MessageID) GetMessageId() uint64 {
	if m != nil {
		return m.MessageId
	}
	return 0
}

type PaymentID struct {
	PaymentId uint64 `protobuf:"varint,1,opt,name=payment_id,json=paymentId,proto3" json:"payment_id,omitempty"`
}

func (m *PaymentID) Reset()      { *m = PaymentID{} }
func (*PaymentID) ProtoMessage() {}
func (*PaymentID) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{6}
}
func (m *PaymentID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PaymentID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentID.Merge(dst, src)
}
func (m *PaymentID) XXX_Size() int {
	return m.Size()
}
func (m *PaymentID) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentID.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentID proto.InternalMessageInfo

func (m *PaymentID) GetPaymentId() uint64 {
	if m != nil {
		return m.PaymentId
	}
	return 0
}

type PaymentAmount struct {
	PaymentAmount uint64 `protobuf:"varint,1,opt,name=payment_amount,json=paymentAmount,proto3" json:"payment_amount,omitempty"`
}

func (m *PaymentAmount) Reset()      { *m = PaymentAmount{} }
func (*PaymentAmount) ProtoMessage() {}
func (*PaymentAmount) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{7}
}
func (m *PaymentAmount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PaymentAmount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PaymentAmount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *PaymentAmount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PaymentAmount.Merge(dst, src)
}
func (m *PaymentAmount) XXX_Size() int {
	return m.Size()
}
func (m *PaymentAmount) XXX_DiscardUnknown() {
	xxx_messageInfo_PaymentAmount.DiscardUnknown(m)
}

var xxx_messageInfo_PaymentAmount proto.InternalMessageInfo

func (m *PaymentAmount) GetPaymentAmount() uint64 {
	if m != nil {
		return m.PaymentAmount
	}
	return 0
}

type SecretHash struct {
	SecretHash []byte `protobuf:"bytes,1,opt,name=secret_hash,json=secretHash,proto3" json:"secret_hash,omitempty"`
}

func (m *SecretHash) Reset()      { *m = SecretHash{} }
func (*SecretHash) ProtoMessage() {}
func (*SecretHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{8}
}
func (m *SecretHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SecretHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretHash.Merge(dst, src)
}
func (m *SecretHash) XXX_Size() int {
	return m.Size()
}
func (m *SecretHash) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretHash.DiscardUnknown(m)
}

var xxx_messageInfo_SecretHash proto.InternalMessageInfo

func (m *SecretHash) GetSecretHash() []byte {
	if m != nil {
		return m.SecretHash
	}
	return nil
}

type BlockExpiration struct {
	BlockExpiration uint64 `protobuf:"varint,1,opt,name=block_expiration,json=blockExpiration,proto3" json:"block_expiration,omitempty"`
}

func (m *BlockExpiration) Reset()      { *m = BlockExpiration{} }
func (*BlockExpiration) ProtoMessage() {}
func (*BlockExpiration) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{9}
}
func (m *BlockExpiration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockExpiration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockExpiration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *BlockExpiration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockExpiration.Merge(dst, src)
}
func (m *BlockExpiration) XXX_Size() int {
	return m.Size()
}
func (m *BlockExpiration) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockExpiration.DiscardUnknown(m)
}

var xxx_messageInfo_BlockExpiration proto.InternalMessageInfo

func (m *BlockExpiration) GetBlockExpiration() uint64 {
	if m != nil {
		return m.BlockExpiration
	}
	return 0
}

type SecretType struct {
	Secret []byte `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *SecretType) Reset()      { *m = SecretType{} }
func (*SecretType) ProtoMessage() {}
func (*SecretType) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{10}
}
func (m *SecretType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SecretType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretType.Merge(dst, src)
}
func (m *SecretType) XXX_Size() int {
	return m.Size()
}
func (m *SecretType) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretType.DiscardUnknown(m)
}

var xxx_messageInfo_SecretType proto.InternalMessageInfo

func (m *SecretType) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

type Address struct {
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Address) Reset()      { *m = Address{} }
func (*Address) ProtoMessage() {}
func (*Address) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{11}
}
func (m *Address) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Address) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Address.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Address) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Address.Merge(dst, src)
}
func (m *Address) XXX_Size() int {
	return m.Size()
}
func (m *Address) XXX_DiscardUnknown() {
	xxx_messageInfo_Address.DiscardUnknown(m)
}

var xxx_messageInfo_Address proto.InternalMessageInfo

func (m *Address) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

type HashTimeLock struct {
	Amount     *PaymentAmount   `protobuf:"bytes,1,opt,name=amount" json:"amount,omitempty"`
	Expiration *BlockExpiration `protobuf:"bytes,2,opt,name=expiration" json:"expiration,omitempty"`
	Secrethash *SecretHash      `protobuf:"bytes,3,opt,name=secrethash" json:"secrethash,omitempty"`
}

func (m *HashTimeLock) Reset()      { *m = HashTimeLock{} }
func (*HashTimeLock) ProtoMessage() {}
func (*HashTimeLock) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{12}
}
func (m *HashTimeLock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HashTimeLock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HashTimeLock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *HashTimeLock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashTimeLock.Merge(dst, src)
}
func (m *HashTimeLock) XXX_Size() int {
	return m.Size()
}
func (m *HashTimeLock) XXX_DiscardUnknown() {
	xxx_messageInfo_HashTimeLock.DiscardUnknown(m)
}

var xxx_messageInfo_HashTimeLock proto.InternalMessageInfo

func (m *HashTimeLock) GetAmount() *PaymentAmount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *HashTimeLock) GetExpiration() *BlockExpiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *HashTimeLock) GetSecrethash() *SecretHash {
	if m != nil {
		return m.Secrethash
	}
	return nil
}

// messages definition
// SignedMessage(Message)
type SignedMessage struct {
	Signature []byte   `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Sender    *Address `protobuf:"bytes,2,opt,name=sender" json:"sender,omitempty"`
	Publickey []byte   `protobuf:"bytes,3,opt,name=publickey,proto3" json:"publickey,omitempty"`
}

func (m *SignedMessage) Reset()      { *m = SignedMessage{} }
func (*SignedMessage) ProtoMessage() {}
func (*SignedMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{13}
}
func (m *SignedMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SignedMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedMessage.Merge(dst, src)
}
func (m *SignedMessage) XXX_Size() int {
	return m.Size()
}
func (m *SignedMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SignedMessage proto.InternalMessageInfo

func (m *SignedMessage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *SignedMessage) GetSender() *Address {
	if m != nil {
		return m.Sender
	}
	return nil
}

func (m *SignedMessage) GetPublickey() []byte {
	if m != nil {
		return m.Publickey
	}
	return nil
}

// EnvelopeMessage(SignedMessage)
// !!! check data to sign
type EnvelopeMessage struct {
	ChainId             *ChainID             `protobuf:"bytes,1,opt,name=chain_id,json=chainId" json:"chain_id,omitempty"`
	Nonce               uint64               `protobuf:"varint,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	TransferredAmount   *TokenAmount         `protobuf:"bytes,3,opt,name=transferred_amount,json=transferredAmount" json:"transferred_amount,omitempty"`
	LockedAmount        *TokenAmount         `protobuf:"bytes,4,opt,name=locked_amount,json=lockedAmount" json:"locked_amount,omitempty"`
	Locksroot           *Locksroot           `protobuf:"bytes,5,opt,name=locksroot" json:"locksroot,omitempty"`
	ChannelIdentifier   *ChannelID           `protobuf:"bytes,6,opt,name=channel_identifier,json=channelIdentifier" json:"channel_identifier,omitempty"`
	TokenNetworkAddress *TokenNetworkAddress `protobuf:"bytes,7,opt,name=token_network_address,json=tokenNetworkAddress" json:"token_network_address,omitempty"`
	Signature           *SignedMessage       `protobuf:"bytes,8,opt,name=signature" json:"signature,omitempty"`
}

func (m *EnvelopeMessage) Reset()      { *m = EnvelopeMessage{} }
func (*EnvelopeMessage) ProtoMessage() {}
func (*EnvelopeMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{14}
}
func (m *EnvelopeMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnvelopeMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnvelopeMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *EnvelopeMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnvelopeMessage.Merge(dst, src)
}
func (m *EnvelopeMessage) XXX_Size() int {
	return m.Size()
}
func (m *EnvelopeMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EnvelopeMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EnvelopeMessage proto.InternalMessageInfo

func (m *EnvelopeMessage) GetChainId() *ChainID {
	if m != nil {
		return m.ChainId
	}
	return nil
}

func (m *EnvelopeMessage) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *EnvelopeMessage) GetTransferredAmount() *TokenAmount {
	if m != nil {
		return m.TransferredAmount
	}
	return nil
}

func (m *EnvelopeMessage) GetLockedAmount() *TokenAmount {
	if m != nil {
		return m.LockedAmount
	}
	return nil
}

func (m *EnvelopeMessage) GetLocksroot() *Locksroot {
	if m != nil {
		return m.Locksroot
	}
	return nil
}

func (m *EnvelopeMessage) GetChannelIdentifier() *ChannelID {
	if m != nil {
		return m.ChannelIdentifier
	}
	return nil
}

func (m *EnvelopeMessage) GetTokenNetworkAddress() *TokenNetworkAddress {
	if m != nil {
		return m.TokenNetworkAddress
	}
	return nil
}

func (m *EnvelopeMessage) GetSignature() *SignedMessage {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Processed(SignedMessage)
type Processed struct {
	MessageIdentifier *MessageID     `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	Signature         *SignedMessage `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *Processed) Reset()      { *m = Processed{} }
func (*Processed) ProtoMessage() {}
func (*Processed) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{15}
}
func (m *Processed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Processed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Processed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Processed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Processed.Merge(dst, src)
}
func (m *Processed) XXX_Size() int {
	return m.Size()
}
func (m *Processed) XXX_DiscardUnknown() {
	xxx_messageInfo_Processed.DiscardUnknown(m)
}

var xxx_messageInfo_Processed proto.InternalMessageInfo

func (m *Processed) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *Processed) GetSignature() *SignedMessage {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Delivered(SignedMessage)
type Delivered struct {
	DeliveredMessageIdentifier *MessageID     `protobuf:"bytes,1,opt,name=delivered_message_identifier,json=deliveredMessageIdentifier" json:"delivered_message_identifier,omitempty"`
	Signature                  *SignedMessage `protobuf:"bytes,2,opt,name=signature" json:"signature,omitempty"`
}

func (m *Delivered) Reset()      { *m = Delivered{} }
func (*Delivered) ProtoMessage() {}
func (*Delivered) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{16}
}
func (m *Delivered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delivered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delivered.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Delivered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delivered.Merge(dst, src)
}
func (m *Delivered) XXX_Size() int {
	return m.Size()
}
func (m *Delivered) XXX_DiscardUnknown() {
	xxx_messageInfo_Delivered.DiscardUnknown(m)
}

var xxx_messageInfo_Delivered proto.InternalMessageInfo

func (m *Delivered) GetDeliveredMessageIdentifier() *MessageID {
	if m != nil {
		return m.DeliveredMessageIdentifier
	}
	return nil
}

func (m *Delivered) GetSignature() *SignedMessage {
	if m != nil {
		return m.Signature
	}
	return nil
}

// SecretRequest(SignedMessage)
type SecretRequest struct {
	MessageIdentifier *MessageID       `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	PaymentIdentifier *PaymentID       `protobuf:"bytes,2,opt,name=payment_identifier,json=paymentIdentifier" json:"payment_identifier,omitempty"`
	Secrethash        *SecretHash      `protobuf:"bytes,3,opt,name=secrethash" json:"secrethash,omitempty"`
	Amount            *TokenAmount     `protobuf:"bytes,4,opt,name=amount" json:"amount,omitempty"`
	Expiration        *BlockExpiration `protobuf:"bytes,5,opt,name=expiration" json:"expiration,omitempty"`
	Signature         *SignedMessage   `protobuf:"bytes,6,opt,name=signature" json:"signature,omitempty"`
}

func (m *SecretRequest) Reset()      { *m = SecretRequest{} }
func (*SecretRequest) ProtoMessage() {}
func (*SecretRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{17}
}
func (m *SecretRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *SecretRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretRequest.Merge(dst, src)
}
func (m *SecretRequest) XXX_Size() int {
	return m.Size()
}
func (m *SecretRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SecretRequest proto.InternalMessageInfo

func (m *SecretRequest) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *SecretRequest) GetPaymentIdentifier() *PaymentID {
	if m != nil {
		return m.PaymentIdentifier
	}
	return nil
}

func (m *SecretRequest) GetSecrethash() *SecretHash {
	if m != nil {
		return m.Secrethash
	}
	return nil
}

func (m *SecretRequest) GetAmount() *TokenAmount {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *SecretRequest) GetExpiration() *BlockExpiration {
	if m != nil {
		return m.Expiration
	}
	return nil
}

func (m *SecretRequest) GetSignature() *SignedMessage {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Secret(EnvelopeMessage)
type Secret struct {
	EnvelopeMessage   *EnvelopeMessage `protobuf:"bytes,1,opt,name=envelope_message,json=envelopeMessage" json:"envelope_message,omitempty"`
	MessageIdentifier *MessageID       `protobuf:"bytes,2,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	PaymentIdentifier *PaymentID       `protobuf:"bytes,3,opt,name=payment_identifier,json=paymentIdentifier" json:"payment_identifier,omitempty"`
	Secret            *SecretType      `protobuf:"bytes,4,opt,name=secret" json:"secret,omitempty"`
}

func (m *Secret) Reset()      { *m = Secret{} }
func (*Secret) ProtoMessage() {}
func (*Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{18}
}
func (m *Secret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Secret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Secret.Merge(dst, src)
}
func (m *Secret) XXX_Size() int {
	return m.Size()
}
func (m *Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_Secret proto.InternalMessageInfo

func (m *Secret) GetEnvelopeMessage() *EnvelopeMessage {
	if m != nil {
		return m.EnvelopeMessage
	}
	return nil
}

func (m *Secret) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *Secret) GetPaymentIdentifier() *PaymentID {
	if m != nil {
		return m.PaymentIdentifier
	}
	return nil
}

func (m *Secret) GetSecret() *SecretType {
	if m != nil {
		return m.Secret
	}
	return nil
}

// RevealSecret(SignedMessage)
type RevealSecret struct {
	MessageIdentifier *MessageID     `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	Secret            *SecretType    `protobuf:"bytes,2,opt,name=secret" json:"secret,omitempty"`
	Signature         *SignedMessage `protobuf:"bytes,6,opt,name=signature" json:"signature,omitempty"`
}

func (m *RevealSecret) Reset()      { *m = RevealSecret{} }
func (*RevealSecret) ProtoMessage() {}
func (*RevealSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{19}
}
func (m *RevealSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RevealSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RevealSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RevealSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RevealSecret.Merge(dst, src)
}
func (m *RevealSecret) XXX_Size() int {
	return m.Size()
}
func (m *RevealSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_RevealSecret.DiscardUnknown(m)
}

var xxx_messageInfo_RevealSecret proto.InternalMessageInfo

func (m *RevealSecret) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *RevealSecret) GetSecret() *SecretType {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *RevealSecret) GetSignature() *SignedMessage {
	if m != nil {
		return m.Signature
	}
	return nil
}

// DirectTransfer(EnvelopeMessage)
type DirectTransfer struct {
	EnvelopeMessage   *EnvelopeMessage `protobuf:"bytes,1,opt,name=envelope_message,json=envelopeMessage" json:"envelope_message,omitempty"`
	MessageIdentifier *MessageID       `protobuf:"bytes,2,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	PaymentIdentifier *PaymentID       `protobuf:"bytes,3,opt,name=payment_identifier,json=paymentIdentifier" json:"payment_identifier,omitempty"`
	Token             *Address         `protobuf:"bytes,4,opt,name=token" json:"token,omitempty"`
	Recipient         *Address         `protobuf:"bytes,5,opt,name=recipient" json:"recipient,omitempty"`
}

func (m *DirectTransfer) Reset()      { *m = DirectTransfer{} }
func (*DirectTransfer) ProtoMessage() {}
func (*DirectTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{20}
}
func (m *DirectTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DirectTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DirectTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *DirectTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DirectTransfer.Merge(dst, src)
}
func (m *DirectTransfer) XXX_Size() int {
	return m.Size()
}
func (m *DirectTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_DirectTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_DirectTransfer proto.InternalMessageInfo

func (m *DirectTransfer) GetEnvelopeMessage() *EnvelopeMessage {
	if m != nil {
		return m.EnvelopeMessage
	}
	return nil
}

func (m *DirectTransfer) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *DirectTransfer) GetPaymentIdentifier() *PaymentID {
	if m != nil {
		return m.PaymentIdentifier
	}
	return nil
}

func (m *DirectTransfer) GetToken() *Address {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *DirectTransfer) GetRecipient() *Address {
	if m != nil {
		return m.Recipient
	}
	return nil
}

// LockedTransferBase(EnvelopeMessage)
type LockedTransferBase struct {
	EnvelopeMessage   *EnvelopeMessage `protobuf:"bytes,1,opt,name=envelope_message,json=envelopeMessage" json:"envelope_message,omitempty"`
	MessageIdentifier *MessageID       `protobuf:"bytes,2,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	PaymentIdentifier *PaymentID       `protobuf:"bytes,3,opt,name=payment_identifier,json=paymentIdentifier" json:"payment_identifier,omitempty"`
	Token             *Address         `protobuf:"bytes,4,opt,name=token" json:"token,omitempty"`
	Recipient         *Address         `protobuf:"bytes,5,opt,name=recipient" json:"recipient,omitempty"`
	Lock              *HashTimeLock    `protobuf:"bytes,6,opt,name=lock" json:"lock,omitempty"`
}

func (m *LockedTransferBase) Reset()      { *m = LockedTransferBase{} }
func (*LockedTransferBase) ProtoMessage() {}
func (*LockedTransferBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{21}
}
func (m *LockedTransferBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockedTransferBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockedTransferBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LockedTransferBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockedTransferBase.Merge(dst, src)
}
func (m *LockedTransferBase) XXX_Size() int {
	return m.Size()
}
func (m *LockedTransferBase) XXX_DiscardUnknown() {
	xxx_messageInfo_LockedTransferBase.DiscardUnknown(m)
}

var xxx_messageInfo_LockedTransferBase proto.InternalMessageInfo

func (m *LockedTransferBase) GetEnvelopeMessage() *EnvelopeMessage {
	if m != nil {
		return m.EnvelopeMessage
	}
	return nil
}

func (m *LockedTransferBase) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *LockedTransferBase) GetPaymentIdentifier() *PaymentID {
	if m != nil {
		return m.PaymentIdentifier
	}
	return nil
}

func (m *LockedTransferBase) GetToken() *Address {
	if m != nil {
		return m.Token
	}
	return nil
}

func (m *LockedTransferBase) GetRecipient() *Address {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *LockedTransferBase) GetLock() *HashTimeLock {
	if m != nil {
		return m.Lock
	}
	return nil
}

// LockedTransfer(LockedTransferBase)
type LockedTransfer struct {
	BaseMessage *LockedTransferBase `protobuf:"bytes,1,opt,name=base_message,json=baseMessage" json:"base_message,omitempty"`
	Target      *Address            `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	Initiator   *Address            `protobuf:"bytes,3,opt,name=initiator" json:"initiator,omitempty"`
	Fee         uint32              `protobuf:"varint,4,opt,name=fee,proto3" json:"fee,omitempty"`
}

func (m *LockedTransfer) Reset()      { *m = LockedTransfer{} }
func (*LockedTransfer) ProtoMessage() {}
func (*LockedTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{22}
}
func (m *LockedTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockedTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockedTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LockedTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockedTransfer.Merge(dst, src)
}
func (m *LockedTransfer) XXX_Size() int {
	return m.Size()
}
func (m *LockedTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_LockedTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_LockedTransfer proto.InternalMessageInfo

func (m *LockedTransfer) GetBaseMessage() *LockedTransferBase {
	if m != nil {
		return m.BaseMessage
	}
	return nil
}

func (m *LockedTransfer) GetTarget() *Address {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *LockedTransfer) GetInitiator() *Address {
	if m != nil {
		return m.Initiator
	}
	return nil
}

func (m *LockedTransfer) GetFee() uint32 {
	if m != nil {
		return m.Fee
	}
	return 0
}

// RefundTransfer(LockedTransfer)
type RefundTransfer struct {
	Refund *LockedTransfer `protobuf:"bytes,1,opt,name=refund" json:"refund,omitempty"`
}

func (m *RefundTransfer) Reset()      { *m = RefundTransfer{} }
func (*RefundTransfer) ProtoMessage() {}
func (*RefundTransfer) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{23}
}
func (m *RefundTransfer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefundTransfer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefundTransfer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *RefundTransfer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefundTransfer.Merge(dst, src)
}
func (m *RefundTransfer) XXX_Size() int {
	return m.Size()
}
func (m *RefundTransfer) XXX_DiscardUnknown() {
	xxx_messageInfo_RefundTransfer.DiscardUnknown(m)
}

var xxx_messageInfo_RefundTransfer proto.InternalMessageInfo

func (m *RefundTransfer) GetRefund() *LockedTransfer {
	if m != nil {
		return m.Refund
	}
	return nil
}

// LockExpired(EnvelopeMessage)
type LockExpired struct {
	EnvelopeMessage   *EnvelopeMessage `protobuf:"bytes,1,opt,name=envelope_message,json=envelopeMessage" json:"envelope_message,omitempty"`
	MessageIdentifier *MessageID       `protobuf:"bytes,2,opt,name=message_identifier,json=messageIdentifier" json:"message_identifier,omitempty"`
	Recipient         *Address         `protobuf:"bytes,3,opt,name=recipient" json:"recipient,omitempty"`
	Secrethash        *SecretHash      `protobuf:"bytes,4,opt,name=secrethash" json:"secrethash,omitempty"`
}

func (m *LockExpired) Reset()      { *m = LockExpired{} }
func (*LockExpired) ProtoMessage() {}
func (*LockExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_stream_7f92c13a4d9b54ed, []int{24}
}
func (m *LockExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LockExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LockExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (dst *LockExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LockExpired.Merge(dst, src)
}
func (m *LockExpired) XXX_Size() int {
	return m.Size()
}
func (m *LockExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_LockExpired.DiscardUnknown(m)
}

var xxx_messageInfo_LockExpired proto.InternalMessageInfo

func (m *LockExpired) GetEnvelopeMessage() *EnvelopeMessage {
	if m != nil {
		return m.EnvelopeMessage
	}
	return nil
}

func (m *LockExpired) GetMessageIdentifier() *MessageID {
	if m != nil {
		return m.MessageIdentifier
	}
	return nil
}

func (m *LockExpired) GetRecipient() *Address {
	if m != nil {
		return m.Recipient
	}
	return nil
}

func (m *LockExpired) GetSecrethash() *SecretHash {
	if m != nil {
		return m.Secrethash
	}
	return nil
}

func init() {
	proto.RegisterType((*ChainID)(nil), "messages.ChainID")
	proto.RegisterType((*TokenAmount)(nil), "messages.TokenAmount")
	proto.RegisterType((*Locksroot)(nil), "messages.Locksroot")
	proto.RegisterType((*ChannelID)(nil), "messages.ChannelID")
	proto.RegisterType((*TokenNetworkAddress)(nil), "messages.TokenNetworkAddress")
	proto.RegisterType((*MessageID)(nil), "messages.MessageID")
	proto.RegisterType((*PaymentID)(nil), "messages.PaymentID")
	proto.RegisterType((*PaymentAmount)(nil), "messages.PaymentAmount")
	proto.RegisterType((*SecretHash)(nil), "messages.SecretHash")
	proto.RegisterType((*BlockExpiration)(nil), "messages.BlockExpiration")
	proto.RegisterType((*SecretType)(nil), "messages.SecretType")
	proto.RegisterType((*Address)(nil), "messages.Address")
	proto.RegisterType((*HashTimeLock)(nil), "messages.HashTimeLock")
	proto.RegisterType((*SignedMessage)(nil), "messages.SignedMessage")
	proto.RegisterType((*EnvelopeMessage)(nil), "messages.EnvelopeMessage")
	proto.RegisterType((*Processed)(nil), "messages.Processed")
	proto.RegisterType((*Delivered)(nil), "messages.Delivered")
	proto.RegisterType((*SecretRequest)(nil), "messages.SecretRequest")
	proto.RegisterType((*Secret)(nil), "messages.Secret")
	proto.RegisterType((*RevealSecret)(nil), "messages.RevealSecret")
	proto.RegisterType((*DirectTransfer)(nil), "messages.DirectTransfer")
	proto.RegisterType((*LockedTransferBase)(nil), "messages.LockedTransferBase")
	proto.RegisterType((*LockedTransfer)(nil), "messages.LockedTransfer")
	proto.RegisterType((*RefundTransfer)(nil), "messages.RefundTransfer")
	proto.RegisterType((*LockExpired)(nil), "messages.LockExpired")
}
func (this *ChainID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ChainID)
	if !ok {
		that2, ok := that.(ChainID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ChainID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ChainID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ChainID but is not nil && this == nil")
	}
	if this.ChainId != that1.ChainId {
		return fmt.Errorf("ChainId this(%v) Not Equal that(%v)", this.ChainId, that1.ChainId)
	}
	return nil
}
func (this *ChainID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChainID)
	if !ok {
		that2, ok := that.(ChainID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChainId != that1.ChainId {
		return false
	}
	return true
}
func (this *TokenAmount) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TokenAmount)
	if !ok {
		that2, ok := that.(TokenAmount)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TokenAmount")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TokenAmount but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TokenAmount but is not nil && this == nil")
	}
	if this.TokenAmount != that1.TokenAmount {
		return fmt.Errorf("TokenAmount this(%v) Not Equal that(%v)", this.TokenAmount, that1.TokenAmount)
	}
	return nil
}
func (this *TokenAmount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TokenAmount)
	if !ok {
		that2, ok := that.(TokenAmount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TokenAmount != that1.TokenAmount {
		return false
	}
	return true
}
func (this *Locksroot) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Locksroot)
	if !ok {
		that2, ok := that.(Locksroot)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Locksroot")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Locksroot but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Locksroot but is not nil && this == nil")
	}
	if !bytes.Equal(this.Locksroot, that1.Locksroot) {
		return fmt.Errorf("Locksroot this(%v) Not Equal that(%v)", this.Locksroot, that1.Locksroot)
	}
	return nil
}
func (this *Locksroot) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Locksroot)
	if !ok {
		that2, ok := that.(Locksroot)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Locksroot, that1.Locksroot) {
		return false
	}
	return true
}
func (this *ChannelID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ChannelID)
	if !ok {
		that2, ok := that.(ChannelID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *ChannelID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ChannelID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ChannelID but is not nil && this == nil")
	}
	if this.ChannelId != that1.ChannelId {
		return fmt.Errorf("ChannelId this(%v) Not Equal that(%v)", this.ChannelId, that1.ChannelId)
	}
	return nil
}
func (this *ChannelID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChannelID)
	if !ok {
		that2, ok := that.(ChannelID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChannelId != that1.ChannelId {
		return false
	}
	return true
}
func (this *TokenNetworkAddress) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*TokenNetworkAddress)
	if !ok {
		that2, ok := that.(TokenNetworkAddress)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *TokenNetworkAddress")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *TokenNetworkAddress but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *TokenNetworkAddress but is not nil && this == nil")
	}
	if !bytes.Equal(this.TokenNetworkAddress, that1.TokenNetworkAddress) {
		return fmt.Errorf("TokenNetworkAddress this(%v) Not Equal that(%v)", this.TokenNetworkAddress, that1.TokenNetworkAddress)
	}
	return nil
}
func (this *TokenNetworkAddress) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TokenNetworkAddress)
	if !ok {
		that2, ok := that.(TokenNetworkAddress)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.TokenNetworkAddress, that1.TokenNetworkAddress) {
		return false
	}
	return true
}
func (this *MessageID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*MessageID)
	if !ok {
		that2, ok := that.(MessageID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *MessageID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *MessageID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *MessageID but is not nil && this == nil")
	}
	if this.MessageId != that1.MessageId {
		return fmt.Errorf("MessageId this(%v) Not Equal that(%v)", this.MessageId, that1.MessageId)
	}
	return nil
}
func (this *MessageID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MessageID)
	if !ok {
		that2, ok := that.(MessageID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MessageId != that1.MessageId {
		return false
	}
	return true
}
func (this *PaymentID) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PaymentID)
	if !ok {
		that2, ok := that.(PaymentID)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PaymentID")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PaymentID but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PaymentID but is not nil && this == nil")
	}
	if this.PaymentId != that1.PaymentId {
		return fmt.Errorf("PaymentId this(%v) Not Equal that(%v)", this.PaymentId, that1.PaymentId)
	}
	return nil
}
func (this *PaymentID) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PaymentID)
	if !ok {
		that2, ok := that.(PaymentID)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PaymentId != that1.PaymentId {
		return false
	}
	return true
}
func (this *PaymentAmount) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*PaymentAmount)
	if !ok {
		that2, ok := that.(PaymentAmount)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *PaymentAmount")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *PaymentAmount but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *PaymentAmount but is not nil && this == nil")
	}
	if this.PaymentAmount != that1.PaymentAmount {
		return fmt.Errorf("PaymentAmount this(%v) Not Equal that(%v)", this.PaymentAmount, that1.PaymentAmount)
	}
	return nil
}
func (this *PaymentAmount) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PaymentAmount)
	if !ok {
		that2, ok := that.(PaymentAmount)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PaymentAmount != that1.PaymentAmount {
		return false
	}
	return true
}
func (this *SecretHash) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SecretHash)
	if !ok {
		that2, ok := that.(SecretHash)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SecretHash")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SecretHash but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SecretHash but is not nil && this == nil")
	}
	if !bytes.Equal(this.SecretHash, that1.SecretHash) {
		return fmt.Errorf("SecretHash this(%v) Not Equal that(%v)", this.SecretHash, that1.SecretHash)
	}
	return nil
}
func (this *SecretHash) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretHash)
	if !ok {
		that2, ok := that.(SecretHash)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.SecretHash, that1.SecretHash) {
		return false
	}
	return true
}
func (this *BlockExpiration) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*BlockExpiration)
	if !ok {
		that2, ok := that.(BlockExpiration)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *BlockExpiration")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *BlockExpiration but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *BlockExpiration but is not nil && this == nil")
	}
	if this.BlockExpiration != that1.BlockExpiration {
		return fmt.Errorf("BlockExpiration this(%v) Not Equal that(%v)", this.BlockExpiration, that1.BlockExpiration)
	}
	return nil
}
func (this *BlockExpiration) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BlockExpiration)
	if !ok {
		that2, ok := that.(BlockExpiration)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BlockExpiration != that1.BlockExpiration {
		return false
	}
	return true
}
func (this *SecretType) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SecretType)
	if !ok {
		that2, ok := that.(SecretType)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SecretType")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SecretType but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SecretType but is not nil && this == nil")
	}
	if !bytes.Equal(this.Secret, that1.Secret) {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	return nil
}
func (this *SecretType) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretType)
	if !ok {
		that2, ok := that.(SecretType)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Secret, that1.Secret) {
		return false
	}
	return true
}
func (this *Address) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Address)
	if !ok {
		that2, ok := that.(Address)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Address")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Address but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Address but is not nil && this == nil")
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return fmt.Errorf("Address this(%v) Not Equal that(%v)", this.Address, that1.Address)
	}
	return nil
}
func (this *Address) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Address)
	if !ok {
		that2, ok := that.(Address)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Address, that1.Address) {
		return false
	}
	return true
}
func (this *HashTimeLock) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*HashTimeLock)
	if !ok {
		that2, ok := that.(HashTimeLock)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *HashTimeLock")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *HashTimeLock but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *HashTimeLock but is not nil && this == nil")
	}
	if !this.Amount.Equal(that1.Amount) {
		return fmt.Errorf("Amount this(%v) Not Equal that(%v)", this.Amount, that1.Amount)
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return fmt.Errorf("Expiration this(%v) Not Equal that(%v)", this.Expiration, that1.Expiration)
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return fmt.Errorf("Secrethash this(%v) Not Equal that(%v)", this.Secrethash, that1.Secrethash)
	}
	return nil
}
func (this *HashTimeLock) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HashTimeLock)
	if !ok {
		that2, ok := that.(HashTimeLock)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return false
	}
	return true
}
func (this *SignedMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SignedMessage)
	if !ok {
		that2, ok := that.(SignedMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SignedMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SignedMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SignedMessage but is not nil && this == nil")
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	if !this.Sender.Equal(that1.Sender) {
		return fmt.Errorf("Sender this(%v) Not Equal that(%v)", this.Sender, that1.Sender)
	}
	if !bytes.Equal(this.Publickey, that1.Publickey) {
		return fmt.Errorf("Publickey this(%v) Not Equal that(%v)", this.Publickey, that1.Publickey)
	}
	return nil
}
func (this *SignedMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SignedMessage)
	if !ok {
		that2, ok := that.(SignedMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if !this.Sender.Equal(that1.Sender) {
		return false
	}
	if !bytes.Equal(this.Publickey, that1.Publickey) {
		return false
	}
	return true
}
func (this *EnvelopeMessage) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*EnvelopeMessage)
	if !ok {
		that2, ok := that.(EnvelopeMessage)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *EnvelopeMessage")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *EnvelopeMessage but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *EnvelopeMessage but is not nil && this == nil")
	}
	if !this.ChainId.Equal(that1.ChainId) {
		return fmt.Errorf("ChainId this(%v) Not Equal that(%v)", this.ChainId, that1.ChainId)
	}
	if this.Nonce != that1.Nonce {
		return fmt.Errorf("Nonce this(%v) Not Equal that(%v)", this.Nonce, that1.Nonce)
	}
	if !this.TransferredAmount.Equal(that1.TransferredAmount) {
		return fmt.Errorf("TransferredAmount this(%v) Not Equal that(%v)", this.TransferredAmount, that1.TransferredAmount)
	}
	if !this.LockedAmount.Equal(that1.LockedAmount) {
		return fmt.Errorf("LockedAmount this(%v) Not Equal that(%v)", this.LockedAmount, that1.LockedAmount)
	}
	if !this.Locksroot.Equal(that1.Locksroot) {
		return fmt.Errorf("Locksroot this(%v) Not Equal that(%v)", this.Locksroot, that1.Locksroot)
	}
	if !this.ChannelIdentifier.Equal(that1.ChannelIdentifier) {
		return fmt.Errorf("ChannelIdentifier this(%v) Not Equal that(%v)", this.ChannelIdentifier, that1.ChannelIdentifier)
	}
	if !this.TokenNetworkAddress.Equal(that1.TokenNetworkAddress) {
		return fmt.Errorf("TokenNetworkAddress this(%v) Not Equal that(%v)", this.TokenNetworkAddress, that1.TokenNetworkAddress)
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *EnvelopeMessage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnvelopeMessage)
	if !ok {
		that2, ok := that.(EnvelopeMessage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.ChainId.Equal(that1.ChainId) {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if !this.TransferredAmount.Equal(that1.TransferredAmount) {
		return false
	}
	if !this.LockedAmount.Equal(that1.LockedAmount) {
		return false
	}
	if !this.Locksroot.Equal(that1.Locksroot) {
		return false
	}
	if !this.ChannelIdentifier.Equal(that1.ChannelIdentifier) {
		return false
	}
	if !this.TokenNetworkAddress.Equal(that1.TokenNetworkAddress) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *Processed) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Processed)
	if !ok {
		that2, ok := that.(Processed)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Processed")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Processed but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Processed but is not nil && this == nil")
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *Processed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Processed)
	if !ok {
		that2, ok := that.(Processed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *Delivered) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Delivered)
	if !ok {
		that2, ok := that.(Delivered)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Delivered")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Delivered but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Delivered but is not nil && this == nil")
	}
	if !this.DeliveredMessageIdentifier.Equal(that1.DeliveredMessageIdentifier) {
		return fmt.Errorf("DeliveredMessageIdentifier this(%v) Not Equal that(%v)", this.DeliveredMessageIdentifier, that1.DeliveredMessageIdentifier)
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *Delivered) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Delivered)
	if !ok {
		that2, ok := that.(Delivered)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DeliveredMessageIdentifier.Equal(that1.DeliveredMessageIdentifier) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *SecretRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*SecretRequest)
	if !ok {
		that2, ok := that.(SecretRequest)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *SecretRequest")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *SecretRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *SecretRequest but is not nil && this == nil")
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return fmt.Errorf("PaymentIdentifier this(%v) Not Equal that(%v)", this.PaymentIdentifier, that1.PaymentIdentifier)
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return fmt.Errorf("Secrethash this(%v) Not Equal that(%v)", this.Secrethash, that1.Secrethash)
	}
	if !this.Amount.Equal(that1.Amount) {
		return fmt.Errorf("Amount this(%v) Not Equal that(%v)", this.Amount, that1.Amount)
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return fmt.Errorf("Expiration this(%v) Not Equal that(%v)", this.Expiration, that1.Expiration)
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *SecretRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SecretRequest)
	if !ok {
		that2, ok := that.(SecretRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return false
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return false
	}
	if !this.Amount.Equal(that1.Amount) {
		return false
	}
	if !this.Expiration.Equal(that1.Expiration) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *Secret) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Secret)
	if !ok {
		that2, ok := that.(Secret)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *Secret")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Secret but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Secret but is not nil && this == nil")
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return fmt.Errorf("EnvelopeMessage this(%v) Not Equal that(%v)", this.EnvelopeMessage, that1.EnvelopeMessage)
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return fmt.Errorf("PaymentIdentifier this(%v) Not Equal that(%v)", this.PaymentIdentifier, that1.PaymentIdentifier)
	}
	if !this.Secret.Equal(that1.Secret) {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	return nil
}
func (this *Secret) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Secret)
	if !ok {
		that2, ok := that.(Secret)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	return true
}
func (this *RevealSecret) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RevealSecret)
	if !ok {
		that2, ok := that.(RevealSecret)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RevealSecret")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RevealSecret but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RevealSecret but is not nil && this == nil")
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.Secret.Equal(that1.Secret) {
		return fmt.Errorf("Secret this(%v) Not Equal that(%v)", this.Secret, that1.Secret)
	}
	if !this.Signature.Equal(that1.Signature) {
		return fmt.Errorf("Signature this(%v) Not Equal that(%v)", this.Signature, that1.Signature)
	}
	return nil
}
func (this *RevealSecret) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RevealSecret)
	if !ok {
		that2, ok := that.(RevealSecret)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.Secret.Equal(that1.Secret) {
		return false
	}
	if !this.Signature.Equal(that1.Signature) {
		return false
	}
	return true
}
func (this *DirectTransfer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*DirectTransfer)
	if !ok {
		that2, ok := that.(DirectTransfer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *DirectTransfer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *DirectTransfer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *DirectTransfer but is not nil && this == nil")
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return fmt.Errorf("EnvelopeMessage this(%v) Not Equal that(%v)", this.EnvelopeMessage, that1.EnvelopeMessage)
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return fmt.Errorf("PaymentIdentifier this(%v) Not Equal that(%v)", this.PaymentIdentifier, that1.PaymentIdentifier)
	}
	if !this.Token.Equal(that1.Token) {
		return fmt.Errorf("Token this(%v) Not Equal that(%v)", this.Token, that1.Token)
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return fmt.Errorf("Recipient this(%v) Not Equal that(%v)", this.Recipient, that1.Recipient)
	}
	return nil
}
func (this *DirectTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectTransfer)
	if !ok {
		that2, ok := that.(DirectTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return false
	}
	return true
}
func (this *LockedTransferBase) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LockedTransferBase)
	if !ok {
		that2, ok := that.(LockedTransferBase)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LockedTransferBase")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LockedTransferBase but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LockedTransferBase but is not nil && this == nil")
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return fmt.Errorf("EnvelopeMessage this(%v) Not Equal that(%v)", this.EnvelopeMessage, that1.EnvelopeMessage)
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return fmt.Errorf("PaymentIdentifier this(%v) Not Equal that(%v)", this.PaymentIdentifier, that1.PaymentIdentifier)
	}
	if !this.Token.Equal(that1.Token) {
		return fmt.Errorf("Token this(%v) Not Equal that(%v)", this.Token, that1.Token)
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return fmt.Errorf("Recipient this(%v) Not Equal that(%v)", this.Recipient, that1.Recipient)
	}
	if !this.Lock.Equal(that1.Lock) {
		return fmt.Errorf("Lock this(%v) Not Equal that(%v)", this.Lock, that1.Lock)
	}
	return nil
}
func (this *LockedTransferBase) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LockedTransferBase)
	if !ok {
		that2, ok := that.(LockedTransferBase)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.PaymentIdentifier.Equal(that1.PaymentIdentifier) {
		return false
	}
	if !this.Token.Equal(that1.Token) {
		return false
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return false
	}
	if !this.Lock.Equal(that1.Lock) {
		return false
	}
	return true
}
func (this *LockedTransfer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LockedTransfer)
	if !ok {
		that2, ok := that.(LockedTransfer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LockedTransfer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LockedTransfer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LockedTransfer but is not nil && this == nil")
	}
	if !this.BaseMessage.Equal(that1.BaseMessage) {
		return fmt.Errorf("BaseMessage this(%v) Not Equal that(%v)", this.BaseMessage, that1.BaseMessage)
	}
	if !this.Target.Equal(that1.Target) {
		return fmt.Errorf("Target this(%v) Not Equal that(%v)", this.Target, that1.Target)
	}
	if !this.Initiator.Equal(that1.Initiator) {
		return fmt.Errorf("Initiator this(%v) Not Equal that(%v)", this.Initiator, that1.Initiator)
	}
	if this.Fee != that1.Fee {
		return fmt.Errorf("Fee this(%v) Not Equal that(%v)", this.Fee, that1.Fee)
	}
	return nil
}
func (this *LockedTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LockedTransfer)
	if !ok {
		that2, ok := that.(LockedTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.BaseMessage.Equal(that1.BaseMessage) {
		return false
	}
	if !this.Target.Equal(that1.Target) {
		return false
	}
	if !this.Initiator.Equal(that1.Initiator) {
		return false
	}
	if this.Fee != that1.Fee {
		return false
	}
	return true
}
func (this *RefundTransfer) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*RefundTransfer)
	if !ok {
		that2, ok := that.(RefundTransfer)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *RefundTransfer")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *RefundTransfer but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *RefundTransfer but is not nil && this == nil")
	}
	if !this.Refund.Equal(that1.Refund) {
		return fmt.Errorf("Refund this(%v) Not Equal that(%v)", this.Refund, that1.Refund)
	}
	return nil
}
func (this *RefundTransfer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RefundTransfer)
	if !ok {
		that2, ok := that.(RefundTransfer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Refund.Equal(that1.Refund) {
		return false
	}
	return true
}
func (this *LockExpired) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*LockExpired)
	if !ok {
		that2, ok := that.(LockExpired)
		if ok {
			that1 = &that2
		} else {
			return fmt.Errorf("that is not of type *LockExpired")
		}
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *LockExpired but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *LockExpired but is not nil && this == nil")
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return fmt.Errorf("EnvelopeMessage this(%v) Not Equal that(%v)", this.EnvelopeMessage, that1.EnvelopeMessage)
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return fmt.Errorf("MessageIdentifier this(%v) Not Equal that(%v)", this.MessageIdentifier, that1.MessageIdentifier)
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return fmt.Errorf("Recipient this(%v) Not Equal that(%v)", this.Recipient, that1.Recipient)
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return fmt.Errorf("Secrethash this(%v) Not Equal that(%v)", this.Secrethash, that1.Secrethash)
	}
	return nil
}
func (this *LockExpired) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*LockExpired)
	if !ok {
		that2, ok := that.(LockExpired)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EnvelopeMessage.Equal(that1.EnvelopeMessage) {
		return false
	}
	if !this.MessageIdentifier.Equal(that1.MessageIdentifier) {
		return false
	}
	if !this.Recipient.Equal(that1.Recipient) {
		return false
	}
	if !this.Secrethash.Equal(that1.Secrethash) {
		return false
	}
	return true
}
func (this *ChainID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.ChainID{")
	s = append(s, "ChainId: "+fmt.Sprintf("%#v", this.ChainId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TokenAmount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.TokenAmount{")
	s = append(s, "TokenAmount: "+fmt.Sprintf("%#v", this.TokenAmount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Locksroot) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.Locksroot{")
	s = append(s, "Locksroot: "+fmt.Sprintf("%#v", this.Locksroot)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChannelID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.ChannelID{")
	s = append(s, "ChannelId: "+fmt.Sprintf("%#v", this.ChannelId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TokenNetworkAddress) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.TokenNetworkAddress{")
	s = append(s, "TokenNetworkAddress: "+fmt.Sprintf("%#v", this.TokenNetworkAddress)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *MessageID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.MessageID{")
	s = append(s, "MessageId: "+fmt.Sprintf("%#v", this.MessageId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PaymentID) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.PaymentID{")
	s = append(s, "PaymentId: "+fmt.Sprintf("%#v", this.PaymentId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PaymentAmount) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.PaymentAmount{")
	s = append(s, "PaymentAmount: "+fmt.Sprintf("%#v", this.PaymentAmount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecretHash) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SecretHash{")
	s = append(s, "SecretHash: "+fmt.Sprintf("%#v", this.SecretHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BlockExpiration) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.BlockExpiration{")
	s = append(s, "BlockExpiration: "+fmt.Sprintf("%#v", this.BlockExpiration)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecretType) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.SecretType{")
	s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Address) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.Address{")
	s = append(s, "Address: "+fmt.Sprintf("%#v", this.Address)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HashTimeLock) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.HashTimeLock{")
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	if this.Secrethash != nil {
		s = append(s, "Secrethash: "+fmt.Sprintf("%#v", this.Secrethash)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SignedMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.SignedMessage{")
	s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	if this.Sender != nil {
		s = append(s, "Sender: "+fmt.Sprintf("%#v", this.Sender)+",\n")
	}
	s = append(s, "Publickey: "+fmt.Sprintf("%#v", this.Publickey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *EnvelopeMessage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&messages.EnvelopeMessage{")
	if this.ChainId != nil {
		s = append(s, "ChainId: "+fmt.Sprintf("%#v", this.ChainId)+",\n")
	}
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	if this.TransferredAmount != nil {
		s = append(s, "TransferredAmount: "+fmt.Sprintf("%#v", this.TransferredAmount)+",\n")
	}
	if this.LockedAmount != nil {
		s = append(s, "LockedAmount: "+fmt.Sprintf("%#v", this.LockedAmount)+",\n")
	}
	if this.Locksroot != nil {
		s = append(s, "Locksroot: "+fmt.Sprintf("%#v", this.Locksroot)+",\n")
	}
	if this.ChannelIdentifier != nil {
		s = append(s, "ChannelIdentifier: "+fmt.Sprintf("%#v", this.ChannelIdentifier)+",\n")
	}
	if this.TokenNetworkAddress != nil {
		s = append(s, "TokenNetworkAddress: "+fmt.Sprintf("%#v", this.TokenNetworkAddress)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Processed) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.Processed{")
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Delivered) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&messages.Delivered{")
	if this.DeliveredMessageIdentifier != nil {
		s = append(s, "DeliveredMessageIdentifier: "+fmt.Sprintf("%#v", this.DeliveredMessageIdentifier)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SecretRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&messages.SecretRequest{")
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.PaymentIdentifier != nil {
		s = append(s, "PaymentIdentifier: "+fmt.Sprintf("%#v", this.PaymentIdentifier)+",\n")
	}
	if this.Secrethash != nil {
		s = append(s, "Secrethash: "+fmt.Sprintf("%#v", this.Secrethash)+",\n")
	}
	if this.Amount != nil {
		s = append(s, "Amount: "+fmt.Sprintf("%#v", this.Amount)+",\n")
	}
	if this.Expiration != nil {
		s = append(s, "Expiration: "+fmt.Sprintf("%#v", this.Expiration)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Secret) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.Secret{")
	if this.EnvelopeMessage != nil {
		s = append(s, "EnvelopeMessage: "+fmt.Sprintf("%#v", this.EnvelopeMessage)+",\n")
	}
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.PaymentIdentifier != nil {
		s = append(s, "PaymentIdentifier: "+fmt.Sprintf("%#v", this.PaymentIdentifier)+",\n")
	}
	if this.Secret != nil {
		s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RevealSecret) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&messages.RevealSecret{")
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.Secret != nil {
		s = append(s, "Secret: "+fmt.Sprintf("%#v", this.Secret)+",\n")
	}
	if this.Signature != nil {
		s = append(s, "Signature: "+fmt.Sprintf("%#v", this.Signature)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *DirectTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&messages.DirectTransfer{")
	if this.EnvelopeMessage != nil {
		s = append(s, "EnvelopeMessage: "+fmt.Sprintf("%#v", this.EnvelopeMessage)+",\n")
	}
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.PaymentIdentifier != nil {
		s = append(s, "PaymentIdentifier: "+fmt.Sprintf("%#v", this.PaymentIdentifier)+",\n")
	}
	if this.Token != nil {
		s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	}
	if this.Recipient != nil {
		s = append(s, "Recipient: "+fmt.Sprintf("%#v", this.Recipient)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LockedTransferBase) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&messages.LockedTransferBase{")
	if this.EnvelopeMessage != nil {
		s = append(s, "EnvelopeMessage: "+fmt.Sprintf("%#v", this.EnvelopeMessage)+",\n")
	}
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.PaymentIdentifier != nil {
		s = append(s, "PaymentIdentifier: "+fmt.Sprintf("%#v", this.PaymentIdentifier)+",\n")
	}
	if this.Token != nil {
		s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	}
	if this.Recipient != nil {
		s = append(s, "Recipient: "+fmt.Sprintf("%#v", this.Recipient)+",\n")
	}
	if this.Lock != nil {
		s = append(s, "Lock: "+fmt.Sprintf("%#v", this.Lock)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LockedTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.LockedTransfer{")
	if this.BaseMessage != nil {
		s = append(s, "BaseMessage: "+fmt.Sprintf("%#v", this.BaseMessage)+",\n")
	}
	if this.Target != nil {
		s = append(s, "Target: "+fmt.Sprintf("%#v", this.Target)+",\n")
	}
	if this.Initiator != nil {
		s = append(s, "Initiator: "+fmt.Sprintf("%#v", this.Initiator)+",\n")
	}
	s = append(s, "Fee: "+fmt.Sprintf("%#v", this.Fee)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RefundTransfer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&messages.RefundTransfer{")
	if this.Refund != nil {
		s = append(s, "Refund: "+fmt.Sprintf("%#v", this.Refund)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *LockExpired) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&messages.LockExpired{")
	if this.EnvelopeMessage != nil {
		s = append(s, "EnvelopeMessage: "+fmt.Sprintf("%#v", this.EnvelopeMessage)+",\n")
	}
	if this.MessageIdentifier != nil {
		s = append(s, "MessageIdentifier: "+fmt.Sprintf("%#v", this.MessageIdentifier)+",\n")
	}
	if this.Recipient != nil {
		s = append(s, "Recipient: "+fmt.Sprintf("%#v", this.Recipient)+",\n")
	}
	if this.Secrethash != nil {
		s = append(s, "Secrethash: "+fmt.Sprintf("%#v", this.Secrethash)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStream(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func (m *ChainID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.ChainId))
	}
	return i, nil
}

func (m *TokenAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenAmount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TokenAmount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.TokenAmount))
	}
	return i, nil
}

func (m *Locksroot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Locksroot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Locksroot) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.Locksroot)))
		i += copy(dAtA[i:], m.Locksroot)
	}
	return i, nil
}

func (m *ChannelID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.ChannelId))
	}
	return i, nil
}

func (m *TokenNetworkAddress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenNetworkAddress) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TokenNetworkAddress) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.TokenNetworkAddress)))
		i += copy(dAtA[i:], m.TokenNetworkAddress)
	}
	return i, nil
}

func (m *MessageID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageId))
	}
	return i, nil
}

func (m *PaymentID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PaymentId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentId))
	}
	return i, nil
}

func (m *PaymentAmount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PaymentAmount) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PaymentAmount != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentAmount))
	}
	return i, nil
}

func (m *SecretHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretHash) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SecretHash) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.SecretHash)))
		i += copy(dAtA[i:], m.SecretHash)
	}
	return i, nil
}

func (m *BlockExpiration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockExpiration) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BlockExpiration != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.BlockExpiration))
	}
	return i, nil
}

func (m *SecretType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretType) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Secret) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.Secret)))
		i += copy(dAtA[i:], m.Secret)
	}
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	return i, nil
}

func (m *HashTimeLock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HashTimeLock) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Amount != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Amount.Size()))
		n1, err := m.Amount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Expiration != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Expiration.Size()))
		n2, err := m.Expiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.Secrethash != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Secrethash.Size()))
		n3, err := m.Secrethash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *SignedMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.Signature)))
		i += copy(dAtA[i:], m.Signature)
	}
	if m.Sender != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Sender.Size()))
		n4, err := m.Sender.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Publickey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(len(m.Publickey)))
		i += copy(dAtA[i:], m.Publickey)
	}
	return i, nil
}

func (m *EnvelopeMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnvelopeMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChainId != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.ChainId.Size()))
		n5, err := m.ChainId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Nonce != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Nonce))
	}
	if m.TransferredAmount != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.TransferredAmount.Size()))
		n6, err := m.TransferredAmount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.LockedAmount != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.LockedAmount.Size()))
		n7, err := m.LockedAmount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.Locksroot != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Locksroot.Size()))
		n8, err := m.Locksroot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.ChannelIdentifier != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.ChannelIdentifier.Size()))
		n9, err := m.ChannelIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.TokenNetworkAddress != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.TokenNetworkAddress.Size()))
		n10, err := m.TokenNetworkAddress.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Signature != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Signature.Size()))
		n11, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *Processed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Processed) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n12, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Signature.Size()))
		n13, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *Delivered) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delivered) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DeliveredMessageIdentifier != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.DeliveredMessageIdentifier.Size()))
		n14, err := m.DeliveredMessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Signature != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Signature.Size()))
		n15, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *SecretRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n16, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.PaymentIdentifier != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentIdentifier.Size()))
		n17, err := m.PaymentIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Secrethash != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Secrethash.Size()))
		n18, err := m.Secrethash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Amount != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Amount.Size()))
		n19, err := m.Amount.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Expiration != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Expiration.Size()))
		n20, err := m.Expiration.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Signature != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Signature.Size()))
		n21, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.EnvelopeMessage.Size()))
		n22, err := m.EnvelopeMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.MessageIdentifier != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n23, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.PaymentIdentifier != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentIdentifier.Size()))
		n24, err := m.PaymentIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Secret != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Secret.Size()))
		n25, err := m.Secret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *RevealSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RevealSecret) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n26, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Secret != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Secret.Size()))
		n27, err := m.Secret.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Signature != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Signature.Size()))
		n28, err := m.Signature.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *DirectTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DirectTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.EnvelopeMessage.Size()))
		n29, err := m.EnvelopeMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.MessageIdentifier != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n30, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.PaymentIdentifier != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentIdentifier.Size()))
		n31, err := m.PaymentIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.Token != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Token.Size()))
		n32, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if m.Recipient != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Recipient.Size()))
		n33, err := m.Recipient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	return i, nil
}

func (m *LockedTransferBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockedTransferBase) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.EnvelopeMessage.Size()))
		n34, err := m.EnvelopeMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.MessageIdentifier != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n35, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.PaymentIdentifier != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.PaymentIdentifier.Size()))
		n36, err := m.PaymentIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.Token != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Token.Size()))
		n37, err := m.Token.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Recipient != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Recipient.Size()))
		n38, err := m.Recipient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Lock != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Lock.Size()))
		n39, err := m.Lock.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	return i, nil
}

func (m *LockedTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockedTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.BaseMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.BaseMessage.Size()))
		n40, err := m.BaseMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.Target != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Target.Size()))
		n41, err := m.Target.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.Initiator != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Initiator.Size()))
		n42, err := m.Initiator.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Fee != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Fee))
	}
	return i, nil
}

func (m *RefundTransfer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefundTransfer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Refund != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Refund.Size()))
		n43, err := m.Refund.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	return i, nil
}

func (m *LockExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LockExpired) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.EnvelopeMessage.Size()))
		n44, err := m.EnvelopeMessage.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.MessageIdentifier != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.MessageIdentifier.Size()))
		n45, err := m.MessageIdentifier.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Recipient != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Recipient.Size()))
		n46, err := m.Recipient.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Secrethash != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintStream(dAtA, i, uint64(m.Secrethash.Size()))
		n47, err := m.Secrethash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	return i, nil
}

func encodeVarintStream(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ChainID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != 0 {
		n += 1 + sovStream(uint64(m.ChainId))
	}
	return n
}

func (m *TokenAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokenAmount != 0 {
		n += 1 + sovStream(uint64(m.TokenAmount))
	}
	return n
}

func (m *Locksroot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Locksroot)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *ChannelID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChannelId != 0 {
		n += 1 + sovStream(uint64(m.ChannelId))
	}
	return n
}

func (m *TokenNetworkAddress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TokenNetworkAddress)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *MessageID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageId != 0 {
		n += 1 + sovStream(uint64(m.MessageId))
	}
	return n
}

func (m *PaymentID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PaymentId != 0 {
		n += 1 + sovStream(uint64(m.PaymentId))
	}
	return n
}

func (m *PaymentAmount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PaymentAmount != 0 {
		n += 1 + sovStream(uint64(m.PaymentAmount))
	}
	return n
}

func (m *SecretHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SecretHash)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *BlockExpiration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockExpiration != 0 {
		n += 1 + sovStream(uint64(m.BlockExpiration))
	}
	return n
}

func (m *SecretType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *Address) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *HashTimeLock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Secrethash != nil {
		l = m.Secrethash.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *SignedMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Sender != nil {
		l = m.Sender.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	l = len(m.Publickey)
	if l > 0 {
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *EnvelopeMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainId != nil {
		l = m.ChainId.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Nonce != 0 {
		n += 1 + sovStream(uint64(m.Nonce))
	}
	if m.TransferredAmount != nil {
		l = m.TransferredAmount.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.LockedAmount != nil {
		l = m.LockedAmount.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Locksroot != nil {
		l = m.Locksroot.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.ChannelIdentifier != nil {
		l = m.ChannelIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.TokenNetworkAddress != nil {
		l = m.TokenNetworkAddress.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *Processed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *Delivered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeliveredMessageIdentifier != nil {
		l = m.DeliveredMessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *SecretRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.PaymentIdentifier != nil {
		l = m.PaymentIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Secrethash != nil {
		l = m.Secrethash.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Amount != nil {
		l = m.Amount.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Expiration != nil {
		l = m.Expiration.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *Secret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		l = m.EnvelopeMessage.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.PaymentIdentifier != nil {
		l = m.PaymentIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *RevealSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *DirectTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		l = m.EnvelopeMessage.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.PaymentIdentifier != nil {
		l = m.PaymentIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Recipient != nil {
		l = m.Recipient.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *LockedTransferBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		l = m.EnvelopeMessage.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.PaymentIdentifier != nil {
		l = m.PaymentIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Token != nil {
		l = m.Token.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Recipient != nil {
		l = m.Recipient.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Lock != nil {
		l = m.Lock.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *LockedTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BaseMessage != nil {
		l = m.BaseMessage.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Initiator != nil {
		l = m.Initiator.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Fee != 0 {
		n += 1 + sovStream(uint64(m.Fee))
	}
	return n
}

func (m *RefundTransfer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Refund != nil {
		l = m.Refund.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func (m *LockExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EnvelopeMessage != nil {
		l = m.EnvelopeMessage.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.MessageIdentifier != nil {
		l = m.MessageIdentifier.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Recipient != nil {
		l = m.Recipient.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	if m.Secrethash != nil {
		l = m.Secrethash.Size()
		n += 1 + l + sovStream(uint64(l))
	}
	return n
}

func sovStream(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStream(x uint64) (n int) {
	return sovStream(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *ChainID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChainID{`,
		`ChainId:` + fmt.Sprintf("%v", this.ChainId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TokenAmount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TokenAmount{`,
		`TokenAmount:` + fmt.Sprintf("%v", this.TokenAmount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Locksroot) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Locksroot{`,
		`Locksroot:` + fmt.Sprintf("%v", this.Locksroot) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChannelID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChannelID{`,
		`ChannelId:` + fmt.Sprintf("%v", this.ChannelId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TokenNetworkAddress) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TokenNetworkAddress{`,
		`TokenNetworkAddress:` + fmt.Sprintf("%v", this.TokenNetworkAddress) + `,`,
		`}`,
	}, "")
	return s
}
func (this *MessageID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&MessageID{`,
		`MessageId:` + fmt.Sprintf("%v", this.MessageId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PaymentID) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PaymentID{`,
		`PaymentId:` + fmt.Sprintf("%v", this.PaymentId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PaymentAmount) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PaymentAmount{`,
		`PaymentAmount:` + fmt.Sprintf("%v", this.PaymentAmount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecretHash) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecretHash{`,
		`SecretHash:` + fmt.Sprintf("%v", this.SecretHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BlockExpiration) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BlockExpiration{`,
		`BlockExpiration:` + fmt.Sprintf("%v", this.BlockExpiration) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecretType) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecretType{`,
		`Secret:` + fmt.Sprintf("%v", this.Secret) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Address) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Address{`,
		`Address:` + fmt.Sprintf("%v", this.Address) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HashTimeLock) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HashTimeLock{`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "PaymentAmount", "PaymentAmount", 1) + `,`,
		`Expiration:` + strings.Replace(fmt.Sprintf("%v", this.Expiration), "BlockExpiration", "BlockExpiration", 1) + `,`,
		`Secrethash:` + strings.Replace(fmt.Sprintf("%v", this.Secrethash), "SecretHash", "SecretHash", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SignedMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SignedMessage{`,
		`Signature:` + fmt.Sprintf("%v", this.Signature) + `,`,
		`Sender:` + strings.Replace(fmt.Sprintf("%v", this.Sender), "Address", "Address", 1) + `,`,
		`Publickey:` + fmt.Sprintf("%v", this.Publickey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *EnvelopeMessage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&EnvelopeMessage{`,
		`ChainId:` + strings.Replace(fmt.Sprintf("%v", this.ChainId), "ChainID", "ChainID", 1) + `,`,
		`Nonce:` + fmt.Sprintf("%v", this.Nonce) + `,`,
		`TransferredAmount:` + strings.Replace(fmt.Sprintf("%v", this.TransferredAmount), "TokenAmount", "TokenAmount", 1) + `,`,
		`LockedAmount:` + strings.Replace(fmt.Sprintf("%v", this.LockedAmount), "TokenAmount", "TokenAmount", 1) + `,`,
		`Locksroot:` + strings.Replace(fmt.Sprintf("%v", this.Locksroot), "Locksroot", "Locksroot", 1) + `,`,
		`ChannelIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.ChannelIdentifier), "ChannelID", "ChannelID", 1) + `,`,
		`TokenNetworkAddress:` + strings.Replace(fmt.Sprintf("%v", this.TokenNetworkAddress), "TokenNetworkAddress", "TokenNetworkAddress", 1) + `,`,
		`Signature:` + strings.Replace(fmt.Sprintf("%v", this.Signature), "SignedMessage", "SignedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Processed) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Processed{`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`Signature:` + strings.Replace(fmt.Sprintf("%v", this.Signature), "SignedMessage", "SignedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Delivered) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Delivered{`,
		`DeliveredMessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.DeliveredMessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`Signature:` + strings.Replace(fmt.Sprintf("%v", this.Signature), "SignedMessage", "SignedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SecretRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SecretRequest{`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`PaymentIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.PaymentIdentifier), "PaymentID", "PaymentID", 1) + `,`,
		`Secrethash:` + strings.Replace(fmt.Sprintf("%v", this.Secrethash), "SecretHash", "SecretHash", 1) + `,`,
		`Amount:` + strings.Replace(fmt.Sprintf("%v", this.Amount), "TokenAmount", "TokenAmount", 1) + `,`,
		`Expiration:` + strings.Replace(fmt.Sprintf("%v", this.Expiration), "BlockExpiration", "BlockExpiration", 1) + `,`,
		`Signature:` + strings.Replace(fmt.Sprintf("%v", this.Signature), "SignedMessage", "SignedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Secret) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Secret{`,
		`EnvelopeMessage:` + strings.Replace(fmt.Sprintf("%v", this.EnvelopeMessage), "EnvelopeMessage", "EnvelopeMessage", 1) + `,`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`PaymentIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.PaymentIdentifier), "PaymentID", "PaymentID", 1) + `,`,
		`Secret:` + strings.Replace(fmt.Sprintf("%v", this.Secret), "SecretType", "SecretType", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RevealSecret) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RevealSecret{`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`Secret:` + strings.Replace(fmt.Sprintf("%v", this.Secret), "SecretType", "SecretType", 1) + `,`,
		`Signature:` + strings.Replace(fmt.Sprintf("%v", this.Signature), "SignedMessage", "SignedMessage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *DirectTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&DirectTransfer{`,
		`EnvelopeMessage:` + strings.Replace(fmt.Sprintf("%v", this.EnvelopeMessage), "EnvelopeMessage", "EnvelopeMessage", 1) + `,`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`PaymentIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.PaymentIdentifier), "PaymentID", "PaymentID", 1) + `,`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "Address", "Address", 1) + `,`,
		`Recipient:` + strings.Replace(fmt.Sprintf("%v", this.Recipient), "Address", "Address", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LockedTransferBase) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LockedTransferBase{`,
		`EnvelopeMessage:` + strings.Replace(fmt.Sprintf("%v", this.EnvelopeMessage), "EnvelopeMessage", "EnvelopeMessage", 1) + `,`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`PaymentIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.PaymentIdentifier), "PaymentID", "PaymentID", 1) + `,`,
		`Token:` + strings.Replace(fmt.Sprintf("%v", this.Token), "Address", "Address", 1) + `,`,
		`Recipient:` + strings.Replace(fmt.Sprintf("%v", this.Recipient), "Address", "Address", 1) + `,`,
		`Lock:` + strings.Replace(fmt.Sprintf("%v", this.Lock), "HashTimeLock", "HashTimeLock", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LockedTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LockedTransfer{`,
		`BaseMessage:` + strings.Replace(fmt.Sprintf("%v", this.BaseMessage), "LockedTransferBase", "LockedTransferBase", 1) + `,`,
		`Target:` + strings.Replace(fmt.Sprintf("%v", this.Target), "Address", "Address", 1) + `,`,
		`Initiator:` + strings.Replace(fmt.Sprintf("%v", this.Initiator), "Address", "Address", 1) + `,`,
		`Fee:` + fmt.Sprintf("%v", this.Fee) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RefundTransfer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RefundTransfer{`,
		`Refund:` + strings.Replace(fmt.Sprintf("%v", this.Refund), "LockedTransfer", "LockedTransfer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *LockExpired) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&LockExpired{`,
		`EnvelopeMessage:` + strings.Replace(fmt.Sprintf("%v", this.EnvelopeMessage), "EnvelopeMessage", "EnvelopeMessage", 1) + `,`,
		`MessageIdentifier:` + strings.Replace(fmt.Sprintf("%v", this.MessageIdentifier), "MessageID", "MessageID", 1) + `,`,
		`Recipient:` + strings.Replace(fmt.Sprintf("%v", this.Recipient), "Address", "Address", 1) + `,`,
		`Secrethash:` + strings.Replace(fmt.Sprintf("%v", this.Secrethash), "SecretHash", "SecretHash", 1) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStream(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *ChainID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			m.ChainId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChainId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenAmount", wireType)
			}
			m.TokenAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Locksroot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Locksroot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Locksroot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locksroot", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Locksroot = append(m.Locksroot[:0], dAtA[iNdEx:postIndex]...)
			if m.Locksroot == nil {
				m.Locksroot = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenNetworkAddress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenNetworkAddress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenNetworkAddress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenNetworkAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokenNetworkAddress = append(m.TokenNetworkAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.TokenNetworkAddress == nil {
				m.TokenNetworkAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageId", wireType)
			}
			m.MessageId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentId", wireType)
			}
			m.PaymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PaymentAmount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PaymentAmount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PaymentAmount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentAmount", wireType)
			}
			m.PaymentAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PaymentAmount |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretHash = append(m.SecretHash[:0], dAtA[iNdEx:postIndex]...)
			if m.SecretHash == nil {
				m.SecretHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockExpiration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockExpiration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockExpiration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockExpiration", wireType)
			}
			m.BlockExpiration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockExpiration |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HashTimeLock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HashTimeLock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HashTimeLock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &PaymentAmount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &BlockExpiration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrethash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secrethash == nil {
				m.Secrethash = &SecretHash{}
			}
			if err := m.Secrethash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Sender == nil {
				m.Sender = &Address{}
			}
			if err := m.Sender.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publickey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Publickey = append(m.Publickey[:0], dAtA[iNdEx:postIndex]...)
			if m.Publickey == nil {
				m.Publickey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EnvelopeMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnvelopeMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnvelopeMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainId == nil {
				m.ChainId = &ChainID{}
			}
			if err := m.ChainId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferredAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferredAmount == nil {
				m.TransferredAmount = &TokenAmount{}
			}
			if err := m.TransferredAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LockedAmount == nil {
				m.LockedAmount = &TokenAmount{}
			}
			if err := m.LockedAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locksroot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locksroot == nil {
				m.Locksroot = &Locksroot{}
			}
			if err := m.Locksroot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChannelIdentifier == nil {
				m.ChannelIdentifier = &ChannelID{}
			}
			if err := m.ChannelIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenNetworkAddress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TokenNetworkAddress == nil {
				m.TokenNetworkAddress = &TokenNetworkAddress{}
			}
			if err := m.TokenNetworkAddress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &SignedMessage{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Processed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Processed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Processed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &SignedMessage{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delivered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delivered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delivered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveredMessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeliveredMessageIdentifier == nil {
				m.DeliveredMessageIdentifier = &MessageID{}
			}
			if err := m.DeliveredMessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &SignedMessage{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentIdentifier == nil {
				m.PaymentIdentifier = &PaymentID{}
			}
			if err := m.PaymentIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrethash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secrethash == nil {
				m.Secrethash = &SecretHash{}
			}
			if err := m.Secrethash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Amount == nil {
				m.Amount = &TokenAmount{}
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expiration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expiration == nil {
				m.Expiration = &BlockExpiration{}
			}
			if err := m.Expiration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &SignedMessage{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvelopeMessage == nil {
				m.EnvelopeMessage = &EnvelopeMessage{}
			}
			if err := m.EnvelopeMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentIdentifier == nil {
				m.PaymentIdentifier = &PaymentID{}
			}
			if err := m.PaymentIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &SecretType{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RevealSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RevealSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RevealSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &SecretType{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &SignedMessage{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DirectTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DirectTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DirectTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvelopeMessage == nil {
				m.EnvelopeMessage = &EnvelopeMessage{}
			}
			if err := m.EnvelopeMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentIdentifier == nil {
				m.PaymentIdentifier = &PaymentID{}
			}
			if err := m.PaymentIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &Address{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recipient == nil {
				m.Recipient = &Address{}
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockedTransferBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockedTransferBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockedTransferBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvelopeMessage == nil {
				m.EnvelopeMessage = &EnvelopeMessage{}
			}
			if err := m.EnvelopeMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaymentIdentifier == nil {
				m.PaymentIdentifier = &PaymentID{}
			}
			if err := m.PaymentIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Token == nil {
				m.Token = &Address{}
			}
			if err := m.Token.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recipient == nil {
				m.Recipient = &Address{}
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Lock == nil {
				m.Lock = &HashTimeLock{}
			}
			if err := m.Lock.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockedTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockedTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockedTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BaseMessage == nil {
				m.BaseMessage = &LockedTransferBase{}
			}
			if err := m.BaseMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Address{}
			}
			if err := m.Target.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initiator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initiator == nil {
				m.Initiator = &Address{}
			}
			if err := m.Initiator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			m.Fee = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Fee |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefundTransfer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefundTransfer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefundTransfer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Refund", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Refund == nil {
				m.Refund = &LockedTransfer{}
			}
			if err := m.Refund.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LockExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStream
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LockExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LockExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EnvelopeMessage == nil {
				m.EnvelopeMessage = &EnvelopeMessage{}
			}
			if err := m.EnvelopeMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageIdentifier", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MessageIdentifier == nil {
				m.MessageIdentifier = &MessageID{}
			}
			if err := m.MessageIdentifier.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Recipient == nil {
				m.Recipient = &Address{}
			}
			if err := m.Recipient.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrethash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStream
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStream
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secrethash == nil {
				m.Secrethash = &SecretHash{}
			}
			if err := m.Secrethash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStream(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStream
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStream(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStream
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStream
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStream
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStream
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStream
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStream(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStream = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStream   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("examples/raiden/messages/stream.proto", fileDescriptor_stream_7f92c13a4d9b54ed)
}

var fileDescriptor_stream_7f92c13a4d9b54ed = []byte{
	// 1075 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x57, 0xcd, 0x6f, 0x1b, 0x45,
	0x14, 0xcf, 0x3a, 0x8e, 0x13, 0x3f, 0xdb, 0xf9, 0x98, 0xb4, 0x25, 0xad, 0xd2, 0x05, 0x96, 0x56,
	0x90, 0x2a, 0x8d, 0x4b, 0xf9, 0x90, 0x40, 0x48, 0xa8, 0xae, 0x2b, 0x61, 0x29, 0x45, 0x65, 0x1a,
	0xce, 0xd6, 0xda, 0xfb, 0x6c, 0xaf, 0x62, 0xcf, 0x9a, 0xd9, 0x71, 0x68, 0x6e, 0x1c, 0x10, 0x67,
	0xae, 0xfc, 0x07, 0x1c, 0xb9, 0xc1, 0x8d, 0x2b, 0xc7, 0x1e, 0x73, 0x6c, 0x9c, 0x0b, 0x27, 0xc4,
	0x5f, 0x80, 0xd0, 0xcc, 0xce, 0xce, 0x7e, 0xe0, 0x16, 0xa7, 0xca, 0x01, 0xa1, 0xde, 0xfc, 0x5e,
	0x7e, 0x6f, 0xe6, 0xbd, 0xdf, 0x7b, 0xef, 0x37, 0x1b, 0xb8, 0x89, 0x4f, 0xdc, 0xd1, 0x78, 0x88,
	0x61, 0x9d, 0xbb, 0xbe, 0x87, 0xac, 0x3e, 0xc2, 0x30, 0x74, 0xfb, 0x18, 0xd6, 0x43, 0xc1, 0xd1,
	0x1d, 0xed, 0x8d, 0x79, 0x20, 0x02, 0xb2, 0x12, 0xbb, 0xaf, 0x39, 0xfd, 0xa0, 0x1f, 0xd4, 0x95,
	0xb7, 0x33, 0xe9, 0xd5, 0xa5, 0xa5, 0x0c, 0xf5, 0x2b, 0x42, 0x3b, 0x37, 0x60, 0xf9, 0xfe, 0xc0,
	0xf5, 0x59, 0xab, 0x49, 0xae, 0xc2, 0x4a, 0x57, 0xfe, 0x6c, 0xfb, 0xde, 0x96, 0xf5, 0x86, 0xf5,
	0x4e, 0x91, 0x2e, 0x2b, 0xbb, 0xe5, 0x39, 0x77, 0xa0, 0x72, 0x10, 0x1c, 0x22, 0xbb, 0x37, 0x0a,
	0x26, 0x4c, 0x90, 0x37, 0xa1, 0x2a, 0xa4, 0xd9, 0x76, 0x95, 0xad, 0xd1, 0x15, 0x91, 0x40, 0x9c,
	0x1d, 0x28, 0xef, 0x07, 0xdd, 0xc3, 0x90, 0x07, 0x81, 0x20, 0xdb, 0x50, 0x1e, 0xc6, 0x86, 0x02,
	0x57, 0x69, 0xe2, 0x70, 0x6e, 0x41, 0xf9, 0xfe, 0xc0, 0x65, 0x0c, 0x87, 0xad, 0x26, 0xb9, 0x0e,
	0xd0, 0x8d, 0x8c, 0x24, 0x8d, 0xb2, 0xf6, 0xb4, 0x3c, 0xa7, 0x05, 0x9b, 0x2a, 0x91, 0xcf, 0x51,
	0x7c, 0x1d, 0xf0, 0xc3, 0x7b, 0x9e, 0xc7, 0x31, 0x0c, 0xc9, 0x5d, 0xb8, 0x1c, 0x25, 0xc4, 0x22,
	0x7f, 0xdb, 0x8d, 0xfe, 0xa0, 0x2f, 0xdb, 0x14, 0xff, 0x8c, 0x91, 0xd7, 0x3e, 0x8c, 0x98, 0x8a,
	0xae, 0xd5, 0xb4, 0xa5, 0xae, 0xd5, 0x9e, 0x96, 0x27, 0xb1, 0x8f, 0xdc, 0xe3, 0x11, 0x32, 0x11,
	0x61, 0xc7, 0x91, 0x91, 0xc2, 0x6a, 0x4f, 0xcb, 0x73, 0x3e, 0x84, 0x9a, 0xc6, 0x6a, 0xb6, 0x6e,
	0xc2, 0x6a, 0x8c, 0xcf, 0xf0, 0x55, 0x1b, 0xa7, 0x61, 0xce, 0x6d, 0x80, 0xc7, 0xd8, 0xe5, 0x28,
	0x3e, 0x73, 0xc3, 0x01, 0x79, 0x1d, 0x2a, 0xa1, 0xb2, 0xda, 0x03, 0x37, 0x1c, 0xe8, 0x3a, 0x20,
	0x34, 0x00, 0xe7, 0x13, 0x58, 0x6b, 0x48, 0x0e, 0x1f, 0x3c, 0x19, 0xfb, 0xdc, 0x15, 0x7e, 0xc0,
	0xc8, 0x0e, 0xac, 0x77, 0xa4, 0xab, 0x8d, 0xc6, 0xa7, 0xaf, 0x5a, 0xeb, 0x64, 0xa1, 0xce, 0x8d,
	0xf8, 0xb2, 0x83, 0xe3, 0x31, 0x92, 0x2b, 0x50, 0x8a, 0x4e, 0xd6, 0xf7, 0x68, 0xcb, 0x79, 0x0b,
	0x96, 0x63, 0x86, 0xb7, 0x60, 0x39, 0xcb, 0x69, 0x6c, 0x3a, 0x3f, 0x59, 0x50, 0x95, 0x19, 0x1d,
	0xf8, 0x23, 0x94, 0x2d, 0x27, 0x75, 0x28, 0xa5, 0xea, 0xac, 0xdc, 0x7d, 0x6d, 0x2f, 0x9e, 0xc8,
	0xbd, 0x0c, 0x31, 0x54, 0xc3, 0xc8, 0x47, 0x00, 0xa9, 0x8c, 0x0b, 0x2a, 0xe8, 0x6a, 0x12, 0x94,
	0x2b, 0x93, 0xa6, 0xc0, 0xe4, 0x7d, 0xd0, 0x9c, 0x28, 0x96, 0x16, 0x55, 0xe8, 0xa5, 0x24, 0x34,
	0x21, 0x94, 0xa6, 0x70, 0xce, 0x11, 0xd4, 0x1e, 0xfb, 0x7d, 0x86, 0x9e, 0x1e, 0x00, 0x39, 0xa0,
	0xa1, 0xdf, 0x67, 0xae, 0x98, 0x70, 0x8c, 0x07, 0xd4, 0x38, 0xc8, 0x8e, 0xa4, 0x87, 0x79, 0xc8,
	0x75, 0x6e, 0x1b, 0xc9, 0x05, 0x9a, 0x1e, 0xaa, 0x01, 0xf2, 0xa0, 0xf1, 0xa4, 0x33, 0xf4, 0xbb,
	0x87, 0x78, 0xac, 0xd2, 0xa9, 0xd2, 0xc4, 0xe1, 0x9c, 0x2c, 0xc2, 0xda, 0x03, 0x76, 0x84, 0xc3,
	0x60, 0x8c, 0xf1, 0xd5, 0xbb, 0xb9, 0xad, 0xcb, 0x1c, 0xaf, 0x57, 0xd3, 0x2c, 0x22, 0xb9, 0x04,
	0x4b, 0x2c, 0x60, 0x5d, 0x54, 0x99, 0x14, 0x69, 0x64, 0x90, 0x26, 0x10, 0xc1, 0x5d, 0x16, 0xf6,
	0x90, 0x73, 0xf4, 0xe2, 0x29, 0x8b, 0xd8, 0xb8, 0x9c, 0x9c, 0x96, 0x5a, 0x61, 0xba, 0x91, 0x0a,
	0xd0, 0x73, 0xfa, 0x31, 0xd4, 0x24, 0xd3, 0xc9, 0x01, 0xc5, 0x17, 0x1d, 0x50, 0x8d, 0xb0, 0x3a,
	0xf6, 0xdd, 0xf4, 0x86, 0x2f, 0xa9, 0xb8, 0xcd, 0x24, 0xce, 0x28, 0x41, 0x6a, 0xed, 0x49, 0x03,
	0x48, 0xb2, 0xe9, 0xc8, 0x84, 0xdf, 0xf3, 0x91, 0x6f, 0x95, 0xf2, 0xb1, 0x46, 0x1a, 0xe8, 0x86,
	0x91, 0x81, 0x18, 0x4d, 0xbe, 0x78, 0xde, 0xde, 0x2f, 0xab, 0x63, 0xae, 0xe7, 0x52, 0xcf, 0x2a,
	0xc0, 0x4c, 0x59, 0x20, 0x1f, 0xa4, 0x47, 0x61, 0x25, 0x3f, 0xc0, 0x99, 0xb1, 0x49, 0xcd, 0x88,
	0xf3, 0x9d, 0x05, 0xe5, 0x47, 0x3c, 0xe8, 0x62, 0x18, 0xa2, 0x27, 0x6b, 0x4b, 0xe4, 0xc4, 0xd4,
	0x66, 0xe5, 0x6b, 0x33, 0xfa, 0x43, 0x37, 0x8c, 0xd6, 0x98, 0xda, 0x32, 0x89, 0x14, 0xe6, 0x4e,
	0xe4, 0x07, 0x0b, 0xca, 0x4d, 0x1c, 0xfa, 0x47, 0xc8, 0xd1, 0x23, 0x5f, 0xc2, 0xb6, 0x17, 0x1b,
	0xed, 0xf3, 0xa5, 0x74, 0xcd, 0x04, 0x3e, 0xbc, 0xa8, 0xdc, 0xfe, 0x28, 0x40, 0x2d, 0x5a, 0x49,
	0x8a, 0x5f, 0x4d, 0x30, 0x14, 0x17, 0x42, 0x54, 0x03, 0x48, 0xa2, 0xc7, 0xe6, 0x8c, 0x42, 0xfe,
	0x0c, 0x23, 0xe0, 0x74, 0xc3, 0x88, 0xb5, 0x39, 0xe3, 0xa5, 0x74, 0x84, 0xdc, 0x36, 0x4a, 0xf7,
	0xc2, 0x55, 0x99, 0xad, 0x73, 0x4b, 0xe7, 0xd1, 0xb9, 0x0c, 0xe1, 0xa5, 0xb9, 0x09, 0xff, 0xb6,
	0x00, 0xa5, 0x28, 0x77, 0xd2, 0x84, 0x75, 0xd4, 0xd2, 0x13, 0x0f, 0x82, 0xe6, 0x39, 0x95, 0x42,
	0x4e, 0x9c, 0xe8, 0x1a, 0xe6, 0xd4, 0x6a, 0x76, 0xbf, 0x0a, 0x17, 0xd0, 0xaf, 0xc5, 0x73, 0xf5,
	0x6b, 0xd7, 0xbc, 0x58, 0xc5, 0xd9, 0xbd, 0x92, 0xef, 0x9a, 0x79, 0xc7, 0x7e, 0xb6, 0xa0, 0x4a,
	0xf1, 0x08, 0xdd, 0xa1, 0x26, 0xe3, 0x22, 0xc6, 0x2e, 0x49, 0xa1, 0xf0, 0xef, 0x29, 0xbc, 0x6c,
	0x03, 0x7f, 0x29, 0xc0, 0x6a, 0xd3, 0xe7, 0xd8, 0x15, 0x07, 0x5a, 0xaf, 0xff, 0x67, 0x8d, 0x7c,
	0x1b, 0x96, 0x94, 0x0a, 0xeb, 0x3e, 0xce, 0x78, 0x5a, 0xa3, 0xbf, 0x93, 0x3a, 0x94, 0x39, 0x76,
	0xfd, 0xb1, 0x8f, 0x2c, 0x7e, 0x61, 0x66, 0x80, 0x13, 0x8c, 0xf3, 0x7b, 0x01, 0xc8, 0xbe, 0x7a,
	0xa3, 0x62, 0xea, 0x1a, 0x6e, 0x88, 0xaf, 0xe8, 0x9b, 0x8f, 0x3e, 0x72, 0x0b, 0x8a, 0x52, 0x8f,
	0xf4, 0xac, 0x5e, 0x49, 0xb0, 0xe9, 0x6f, 0x3d, 0xaa, 0x30, 0xce, 0xaf, 0x16, 0xac, 0x66, 0xa9,
	0x26, 0x9f, 0x42, 0xb5, 0xe3, 0x86, 0x79, 0x8a, 0xb7, 0xb3, 0xdf, 0x04, 0xd9, 0xd6, 0xd0, 0x8a,
	0x8c, 0x88, 0x19, 0xde, 0x81, 0x92, 0x70, 0x79, 0xdf, 0xac, 0xd7, 0xac, 0x8f, 0xae, 0x08, 0x20,
	0x6b, 0xf3, 0x99, 0x2f, 0x7c, 0x57, 0x04, 0x31, 0x7f, 0xb3, 0x6a, 0x33, 0x18, 0xb2, 0x0e, 0x8b,
	0x3d, 0x44, 0xc5, 0x59, 0x8d, 0xca, 0x9f, 0x4e, 0x03, 0x56, 0x29, 0xf6, 0x26, 0x2c, 0x29, 0xe0,
	0x0e, 0x94, 0xb8, 0xf2, 0xe8, 0xd4, 0xb7, 0x9e, 0x97, 0x3a, 0xd5, 0x38, 0xe7, 0x2f, 0x0b, 0x2a,
	0xfb, 0xb1, 0x84, 0xa3, 0xf7, 0x1f, 0x9a, 0xb4, 0x4c, 0xf3, 0x17, 0xe7, 0x68, 0x7e, 0xf6, 0x39,
	0x2c, 0xce, 0xf7, 0x1c, 0x36, 0x76, 0x4f, 0x4e, 0xed, 0x85, 0x67, 0xa7, 0xb6, 0xf5, 0xe7, 0xa9,
	0x6d, 0x7d, 0x33, 0xb5, 0xad, 0x1f, 0xa7, 0xb6, 0xf5, 0xdb, 0xd4, 0xb6, 0x9e, 0x4e, 0x6d, 0xeb,
	0xd9, 0xd4, 0xb6, 0xbe, 0x3f, 0xb3, 0x17, 0x9e, 0x9e, 0xd9, 0x0b, 0x27, 0x67, 0xf6, 0x42, 0xa7,
	0xa4, 0xfe, 0x01, 0x7d, 0xef, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9e, 0xc5, 0x17, 0x16, 0xd7,
	0x0e, 0x00, 0x00,
}
